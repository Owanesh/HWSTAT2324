---
title: HW3 - Homework 3
author: Owanesh
layout: post
date: 2023-10-18
category: Practice
---
Have you ever wondered how the Law of Large Numbers works in real-life scenarios? In this project, we'll dive into the world of statistics and probability to demonstrate the fascinating concept that, with a significant number of trials, the distribution of values tends to converge to a normal distribution. To illustrate this, we'll create four graphs with their corresponding histograms, exploring different aspects of the Law of Large Numbers.

#### Assignation

**Part a**

$M$ systems are subject to a series of $N$ attacks. On the x-axis, we indicate the attacks and on the Y-axis we
simulate the accumulation of a "security score" (-1, 1), where the score is -1 if the system is penetrated
and 1 if the system was successfully "shielded" or protected. Simulate the score "trajectories" for all systems,
assuming, for simplicity, a constant penetration probability $p$ at each attack.

**Part b**

Same as before, but simulate the cumulated frequency, say $f$, of penetration. Do the same with the relative
frequency $\frac{f}{number}$ of attacks and the "normalized" ratio: $\frac{f}{\sqrt{number}}$ of attacks.


**Discussion point:**
Is what you see what you expected? What about the averages of the distributions and the shapes of the histograms:
do you see regularities, differences and can you attempt to explain what you see or guessing what are
the "theoretical" limit distribution, when as $N$ increases, and you can make the distribution simulation "more detailed" by increasing $M$ ?




 


### Javascript
Below a brief description of application flow
![Application flow in javascript](../assets/labs/hw3/appFlow.svg)
```js
/** mainpage.html */
        const app = new DynamicObjManager("myCanvas");
        const initialRectSize = { width: 500, height: 300 };
        const probInput = parseFloat(document.getElementById("probInput").value);
            const sysInput = parseInt(document.getElementById("sysInput").value);
            const nAttacks = parseInt(document.getElementById("nAttacks").value);

            const graphSettings = { probability: probInput, nSystems: sysInput, nAttacks: nAttacks };
           
        const graphUISettings = { label:"ScorePoint Graph",fill: "rgba(200, 200, 200, 0.5)", border: "black", borderWidth: 2 }

        const attackManager = new AttackMonitor(graphSettings)
        const attackMatrix = attackManager.getMatrix()

        var graph1 = new AnimatedGraph(app.canvas, {...initialRectSize,x: 50, y: 20},{...graphUISettings,label:"ScorePoint Graph"}, {...graphSettings,mode: "SCR" })
        graph1.setAttackMatrix(attackMatrix)
        var graph2 = new AnimatedGraph(app.canvas, {...initialRectSize,x: 600, y: 20}, {...graphUISettings,label:"Absolute Frequency Graph"}, {...graphSettings,mode: "ABS" })
        graph2.setAttackMatrix(attackMatrix)
        var graph3 = new AnimatedGraph(app.canvas, {...initialRectSize,x: 50, y: 350}, {...graphUISettings,label:"Relative Frequency Graph"}, {...graphSettings,mode: "REL" })
        graph3.setAttackMatrix(attackMatrix)
        var graph4 = new AnimatedGraph(app.canvas, {...initialRectSize,x: 600, y: 350}, {...graphUISettings,label:"Normalized Frequency Graph"}, {...graphSettings,mode: "NOR" })
        graph4.setAttackMatrix(attackMatrix)
        app.addObjects([graph1, graph2,graph3,graph4]);
```

```js
/** animated.js */
    analyzeSystem(attackVector) {
        let x = 0;
        let y = 0;
        this.context.strokeStyle = attackVector[0]['color']
        let numberOfAttacks = attackVector.length - 1
        let baseYaxis = this.rect.y + this.rect.height / 2
        let baseXaxis = this.rect.x
        for (let i = attackVector.length; i > 0; i--) {
            this.context.beginPath();
            if (this.mode === "NOR")
            this.context.lineTo(baseXaxis + x, baseYaxis + (this.rect.height / 11 / numberOfAttacks) * y);

            else
            this.context.moveTo(baseXaxis + x, baseYaxis + (this.rect.height / 5 / numberOfAttacks) * y);
            if (!attackVector[i]) {
                if (this.mode === "SCR") y++
            } else {
                if (this.mode === "REL") y -= (attackVector.length - i) / ((attackVector.length - i));
                else if (this.mode === "NOR") { y -= (attackVector.length - i) / Math.sqrt((attackVector.length - i)); }
                else y--
            }
            x = (attackVector.length - i) * (this.rect.width / (numberOfAttacks));
            if (this.mode === "NOR")
            this.context.lineTo(baseXaxis + x, baseYaxis + (this.rect.height / 11 / numberOfAttacks) * y);

            else
            this.context.lineTo(baseXaxis + x, baseYaxis + (this.rect.height / 5 / numberOfAttacks) * y);
            this.context.stroke();
        }
        return y
    }
```
The creation of attack matrix is in charge of [attackMonitor.js](https://github.com/Owanesh/HWSTAT2324/blob/main/source/JavaScript/HW3/attackMonitor.js)
```js
 buildMatrix() {
        const matrix = [];
        for (let i = 0; i < this.nSys; i++) {
            const row = [];
            row.push({color:"#" + ((1 << 24) * Math.random() | 0).toString(16),final:0})
            for (let j = 0; j < this.nAtk; j++) {
                // Populates the matrix with true or false based on the attack probability
                row.push(Math.random() <= this.probability ? true : false);
            }
            matrix.push(row);
        }
        return matrix;
    }
```
With this matrix we have a unique color for each system, that is shared among charts. And each graph with relative logic populate field "final", that represents the final score of selected system.

[Try It ðŸ•¹ï¸](../assets/labs/hw3/exercise.html)

![Graph example](../assets/labs/hw3/graph_sample.png)

For this homework, also class Rectangle have to be built, with all interfaces for drag and resize action. Full implementation is available 
[Here](https://github.com/Owanesh/HWSTAT2324/blob/main/source/JavaScript/HW3/utils/shapes.js)
### CSharp


## Conclusion

This experiment vividly illustrates the power of the Law of Large Numbers. As we increase the number of trials, the erratic and unpredictable nature of small samples gradually transforms into a more stable and predictable distribution. Whether we're examining scores or the frequencies of success and failure, the result is always a convergence towards a normal distribution.

This fundamental concept underpins many aspects of statistics, data analysis, and decision-making. Understanding the Law of Large Numbers allows us to make more accurate predictions and informed decisions based on data.